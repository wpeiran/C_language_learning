## 文件输入/输出

文件是当今计算机系统不可或缺的部分。**文件**用于*存储*<u>程序、文档、数据、书信、表格、图形、照片、视频和许多其他种类的</u>**信息**。

### 文件是什么

- **文件**（file）通常<u>是在磁盘或固态硬盘上的一段已命名的</u>**存储区**。
- **C** 把**文件**看作<u>是一系列连续的</u>**字节**，**每个字节**都能被**单独读取**。这与 UNIX 环境中（C 的发源地）的文件结构相对应。由于其他环境中可能无法完全对应这个模型，C 提供**两种文件模式**：**文本模式**和**二进制模式**。

### 文本模式和二进制模式

区分“**文本内容**和**二进制内容**、**文本文件格式**和**二进制文件格式**，以及**文件的文本模式**和**二进制模式**”。

**所有文件的内容都以二进制形式（0 和 1）储存**。

- 如果**文件**最初使用<u>二进制编码的</u>**字符**（例如，**ASCII** 或 **Unicode**）表示**文本**（就像 **C 字符串**那样），**该文件**就是**文本文件**，其中包含**文本内容**。
- 如果<u>文件中的</u>**二进制值**代表**代码**或**数值数据**（使用相同的内部表示，假设，用于 long 或 double 类型的值）或**图片**或**音乐编码**，**该文件**就是**二进制文件**，其中包含**二进制内容**。

**为了规范文本文件的处理**，**C** 提供了**两种访问文件的途径**：**二进制模式**和**文本模式**。

- 在**二进制模式**中，**程序可以访问文件的每个字节**。如果读写一个旧式的 MS-DOS 文本文件，程序会看到文件中的 \r 和 \n 字符，不会发生映射。

- 而在**文本模式**中，**程序所见的内容和文件的实际内部不同**。**程序以文本模式读取文件时**，<u>把本地环境表示的</u>**行末尾**或**文件结尾**映射为 **C 模式**。—— 例如，C 程序在旧式的 Mac 中以文本模式读取文件时，把文件中的 \r 转换成 \n；以文本模式写入文件时，把 \n 转换成 \r。或者，C 文本模式程序在 MS-DOS 平台读取文件时，把\r\n 转换成 \n；写入文件时，把 \n 转换成 \r\n。在其他环境中编写的文本模式程序也会做类似的转换。

  ![](C:\Users\Administrator\Desktop\C语言特性\二进制模式和文本模式.jpg)

  虽然 C 提供了二进制模式和文本模式，但是这两种模式的实现可以相同。

### I/O的级别

除了选择文件的模式，大多数情况下，还可以选择I/O两个级别（即**处理文件访问的两个级别**）。**底层I/O** (low-level I/O) **使用操作系统提供的基本 I/O 服务**。**标准高级 I/O** （standard high-level I/O）**使用 C 库的标准包和 stdio.h 头文件定义**。因为无法保证所有的操作系统都使用相同的底层 I/O 模型，**C 标准只支持标准 I/O 包**。有些实现会提供底层库，但是 C  标准建立了可移植的 I/O 模型，我们主要讨论这些 I/O。

### 标准文件

**C 程序会自动打开 3 个文件**，它们被称为**标准输入**、**标准输出**和**标准错误输出**。在默认情况下，标准输入是系统的普通输入设备，通常为键盘；标准输出和标准错误输出是系统的普通输出设备，通常是显示屏。

通常，标准输入为程序提供输入，它是 getchar() 和 scanf() 使用的文件。程序通常输出到标准输出，它是 putchar()、puts() 和 printf() 使用的文件。重定向把其他文件视为标准输入或标准输出。标准错误输出提供了一个逻辑上不同的地方来发送错误信息。例如，如果使用重定向把输出发送给文件而不是屏幕，那么发送至标准错误输出的内容仍然会被发送到屏幕上。这样很好，因为如果把错误消息发送至文件，就只能打开文件才能看到。

![](C:\Users\Administrator\Desktop\C语言特性\标准文件和相关联的文件指针.jpg)

### 标准 I/O

与底层 I/O 相比，**标准 I/O 包**除了**可移植**以外**还有两个好处**。

- **第一**，**标准 I/O 有许多专门的函数简化了处理不同 I/O 的问题**。—— 例如，printf() 函数把不同形式的数据转换成与终端相适应的字符串输出。
- **第二，输入和输出都是缓冲**。也就是说，**一次转移一大块信息而不是一字节信息（通常至少512字节）**。—— 例如，当程序读取文件时，一块数据被拷贝到缓冲区（一块中介存储区域）。这种缓冲极大地提高了数据传输速率。程序可以检查缓冲区中的字节。缓冲在后台处理，所以让人感觉是逐字符访问的错觉（如果使用底层 I/O，要自己完成大部分工作）。

### 标准 I/O 的机理

以一个典型的概念模型来分析标准 I/O 的工作原理。

通常，使用标准 I/O 的第 1 步是调用 fopen() 打开文件（前面介绍过，C 程序会自动打开 3 种标准文件）。fopen() 函数不仅打开一个文件，还创建了一个缓冲区（在读写模式下会创建两个缓冲区）以及一个包含文件和缓冲区数据的结构。另外，fopen() 返回一个指向该结构的指针，以便其他函数知道如何找到该结构。假如把该指针赋给一个变量 fp，我们说 fopen()函数“打开一个流”。如果以文本模式打开该文件，就获得一个文本流；如果以二进制模式打开文件，就获得一个二进制流。

这个结构通常包含一个指定流中当前位置的文件位置指示器。除此之外，它还包含错误和文件结尾的指示器、一个指向缓冲区开始处的指针、一个文件标识符和一个计数（统计实际拷贝进缓冲区的字节数）。

我们主要考虑文件输入。通常，使用标准 I/O 的第 2 步是调用一个定义在 stdio.h 中的输入函数，如 fscanf()、getc()、fgets()。一调用这些函数，文件中的数据块就被拷贝到缓冲区中。缓冲区的大小因实现而已，一般是 512 字节或是它的倍数，如 4096 或 16384 （随着计算机硬盘容量越来越大，缓冲区的大小也越来越大）。最初调用函数，除了填充缓冲区外，还要设置 fp 所指向的结构中的值。尤其要设置流中的当前位置和拷贝进缓冲区的字节数。通常，当前位置从字节 0 开始。

在初始化结构和缓冲区后，输入函数按要求从缓冲区中读取数据。在它读取数据时，文件位置指示器这设置为指向刚读取字符的下一个字符。由于 stdio.h 系列的所以输入函数都使用相同的缓冲区，所以调用任何一个函数对将从上一次停止的位置开始。

当输入函数发现已读完缓冲区中的所用字符时，会请求把下一个缓冲区大小的数据块从文件拷贝到该缓冲区中。以这种方式，输入函数可以读取文件中的所以内容，直到文件结尾。函数在读取缓冲区中的最后一个字符后，把结尾指示器设置为真。于是，下一次被调用的输入函数将返回 EOF。

输出函数以类似的方式把数据写入缓冲区。当缓冲区被填满时，数据将被拷贝至文件中。

