## 文件输入/输出

文件是当今计算机系统不可或缺的部分。**文件**用于*存储*<u>程序、文档、数据、书信、表格、图形、照片、视频和许多其他种类的</u>**信息**。

### 文件是什么

- **文件**（file）通常<u>是在磁盘或固态硬盘上的一段已命名的</u>**存储区**。
- **C** 把**文件**看作<u>是一系列连续的</u>**字节**，**每个字节**都能被**单独读取**。这与 UNIX 环境中（C 的发源地）的文件结构相对应。由于其他环境中可能无法完全对应这个模型，C 提供**两种文件模式**：**文本模式**和**二进制模式**。

### 文本模式和二进制模式

区分“**文本内容**和**二进制内容**、**文本文件格式**和**二进制文件格式**，以及**文件的文本模式**和**二进制模式**”。

**所有文件的内容都以二进制形式（0 和 1）储存**。

- 如果**文件**最初使用<u>二进制编码的</u>**字符**（例如，**ASCII** 或 **Unicode**）表示**文本**（就像 **C 字符串**那样），**该文件**就是**文本文件**，其中包含**文本内容**。
- 如果<u>文件中的</u>**二进制值**代表**代码**或**数值数据**（使用相同的内部表示，假设，用于 long 或 double 类型的值）或**图片**或**音乐编码**，**该文件**就是**二进制文件**，其中包含**二进制内容**。

**为了规范文本文件的处理**，**C** 提供了**两种访问文件的途径**：**二进制模式**和**文本模式**。

- 在**二进制模式**中，**程序可以访问文件的每个字节**。如果读写一个旧式的 MS-DOS 文本文件，程序会看到文件中的 \r 和 \n 字符，不会发生映射。

- 而在**文本模式**中，**程序所见的内容和文件的实际内部不同**。**程序以文本模式读取文件时**，<u>把本地环境表示的</u>**行末尾**或**文件结尾**映射为 **C 模式**。—— 例如，C 程序在旧式的 Mac 中以文本模式读取文件时，把文件中的 \r 转换成 \n；以文本模式写入文件时，把 \n 转换成 \r。或者，C 文本模式程序在 MS-DOS 平台读取文件时，把\r\n 转换成 \n；写入文件时，把 \n 转换成 \r\n。在其他环境中编写的文本模式程序也会做类似的转换。

  ![](C:\Users\Administrator\Desktop\C语言特性\二进制模式和文本模式.jpg)

  虽然 C 提供了二进制模式和文本模式，但是这两种模式的实现可以相同。
  
- 实际上，所有的数据都是以二进制形式储存的，甚至连字符都以字符码的二进制表示来存储。如果文件中的所有数据都被解释成字符码，则称该文件包含文本数据。如果部分或所有的数据被解释成二进制形式的数值数据，则称该文件包含二进制数据（另外，用数据表示机器语言指令的文件都是二进制文件）。

  ![](C:\Users\Administrator\Desktop\C语言特性\二进制输出和文本输出.png)

  二进制和文本的用法很容易混淆。ANSI C 和许多操作系统都**识别两种文件格式**：**二进制**和**文本**。**能以二进制数据或文本数据形式存储或读取信息**。一般而言，用二进制模式在二进制格式文件中存储二进制数据。类似的，最常用的还是以文本格式打开文本文件中的文本数据（通常文字处理器生成的文件都是二进制文件，因为这些文件中还包含了大量非文本信息，如字体和格式等）。

### I/O的级别

除了选择文件的模式，大多数情况下，还可以选择I/O两个级别（即**处理文件访问的两个级别**）。**底层I/O** (low-level I/O) **使用操作系统提供的基本 I/O 服务**。**标准高级 I/O** （standard high-level I/O）**使用 C 库的标准包和 stdio.h 头文件定义**。因为无法保证所有的操作系统都使用相同的底层 I/O 模型，**C 标准只支持标准 I/O 包**。有些实现会提供底层库，但是 C  标准建立了可移植的 I/O 模型，我们主要讨论这些 I/O。

### 标准文件

**C 程序会自动打开 3 个文件**，它们被称为**标准输入**、**标准输出**和**标准错误输出**。在默认情况下，标准输入是系统的普通输入设备，通常为键盘；标准输出和标准错误输出是系统的普通输出设备，通常是显示屏。

通常，标准输入为程序提供输入，它是 getchar() 和 scanf() 使用的文件。程序通常输出到标准输出，它是 putchar()、puts() 和 printf() 使用的文件。重定向把其他文件视为标准输入或标准输出。标准错误输出提供了一个逻辑上不同的地方来发送错误信息。例如，如果使用重定向把输出发送给文件而不是屏幕，那么发送至标准错误输出的内容仍然会被发送到屏幕上。这样很好，因为如果把错误消息发送至文件，就只能打开文件才能看到。

![](C:\Users\Administrator\Desktop\C语言特性\标准文件和相关联的文件指针.jpg)

### 标准 I/O

与底层 I/O 相比，**标准 I/O 包**除了**可移植**以外**还有两个好处**。

- **第一**，**标准 I/O 有许多专门的函数简化了处理不同 I/O 的问题**。—— 例如，printf() 函数把不同形式的数据转换成与终端相适应的字符串输出。
- **第二，输入和输出都是缓冲**。也就是说，**一次转移一大块信息而不是一字节信息（通常至少512字节）**。—— 例如，当程序读取文件时，一块数据被拷贝到缓冲区（一块中介存储区域）。这种缓冲极大地提高了数据传输速率。程序可以检查缓冲区中的字节。缓冲在后台处理，所以让人感觉是逐字符访问的错觉（如果使用底层 I/O，要自己完成大部分工作）。

### 标准 I/O 的机理

以一个典型的概念模型来分析标准 I/O 的工作原理。

通常，使用标准 I/O 的第 1 步是调用 fopen() 打开文件（前面介绍过，C 程序会自动打开 3 种标准文件）。fopen() 函数不仅打开一个文件，还创建了一个缓冲区（在读写模式下会创建两个缓冲区）以及一个包含文件和缓冲区数据的结构。另外，fopen() 返回一个指向该结构的指针，以便其他函数知道如何找到该结构。假如把该指针赋给一个变量 fp，我们说 fopen()函数“打开一个流”。如果以文本模式打开该文件，就获得一个文本流；如果以二进制模式打开文件，就获得一个二进制流。

这个结构通常包含一个指定流中当前位置的文件位置指示器。除此之外，它还包含错误和文件结尾的指示器、一个指向缓冲区开始处的指针、一个文件标识符和一个计数（统计实际拷贝进缓冲区的字节数）。

我们主要考虑文件输入。通常，使用标准 I/O 的第 2 步是调用一个定义在 stdio.h 中的输入函数，如 fscanf()、getc()、fgets()。一调用这些函数，文件中的数据块就被拷贝到缓冲区中。缓冲区的大小因实现而已，一般是 512 字节或是它的倍数，如 4096 或 16384 （随着计算机硬盘容量越来越大，缓冲区的大小也越来越大）。最初调用函数，除了填充缓冲区外，还要设置 fp 所指向的结构中的值。尤其要设置流中的当前位置和拷贝进缓冲区的字节数。通常，当前位置从字节 0 开始。

在初始化结构和缓冲区后，输入函数按要求从缓冲区中读取数据。在它读取数据时，文件位置指示器这设置为指向刚读取字符的下一个字符。由于 stdio.h 系列的所以输入函数都使用相同的缓冲区，所以调用任何一个函数对将从上一次停止的位置开始。

当输入函数发现已读完缓冲区中的所用字符时，会请求把下一个缓冲区大小的数据块从文件拷贝到该缓冲区中。以这种方式，输入函数可以读取文件中的所以内容，直到文件结尾。函数在读取缓冲区中的最后一个字符后，把结尾指示器设置为真。于是，下一次被调用的输入函数将返回 EOF。

输出函数以类似的方式把数据写入缓冲区。当缓冲区被填满时，数据将被拷贝至文件中。

### 关键概念

C 程序把**输入**看作是**字节流**，输入流来源于**文件**、**输入设备**（如**键盘**），或者甚至是<u>另一个程序的</u>**输出**。类似的，C 程序把**输出**也看作是**字节流**，输出流的目的地可以是**文件**、**显示屏幕**等。

**C 如何解释输入流或输出流取决于所使用的输入/输出函数**。程序可以不做任何改动的读取和存储字节，或者把字节一次解释称字符，随后可以把这些字符解释成普通文本以用文本表示数字。类似地，对于输出，所使用的函数决定了二进制值是被原样转移，还是被转换成文本或以文本表示的数字。如果要在不损失精度的前提下保存或恢复数值数据，请示用二进制模式以及 fread() 和 fwrite() 函数。如果打算保存文本信息并创建能在普通文本编辑器查看的文本，请使用文本模式和函数（如 getc() 和 fprintf()）。

要访问文件，必须创建文件指针（类型是 FILE *）并把指针与特定文件名相关联。随后的代码就可以使用这个指针（而不是文件名）来处理该文件。

要重点理解 C 如何处理文件结尾。通常，用于读取文件的程序使用一个循环读取输入，直至到达文件结尾。C 输入函数在读过文件结尾后才会检测到文件结尾，这意味着应该在尝试读取之后立即判断是否是文件结尾。

### 本章小结

对于大多数 C 程序而言，写入文件和读取文件必不可少。为此，绝大多数 C 实现都提供底层 I/O 和标准高级 I/O。因为 ANSI C 库考虑到可移植性，包含了标准 I/O 包，但是未提供底层 I/O。

标准 I/O 包自动创建输入和输出缓冲区以加快数据传输。fopen() 函数为标准 I/O 打开一个文件，并创建一个用于存储文件和缓冲区信息的结构。fopen() 函数返回指向该结构的指针，其他函数可以使用该指针指定待处理的文件。feof() 和 ferror() 函数报告 I/O 操作失败的原因。

C 把输入视为字节流。如果使用fread() 函数，C 把输入看作是二进制值并将其储存在指定存储位置。如果使用 fscanf()、getc()、fgets() 或其他相关函数，C 则将每个字节看作是字符码。然后 fscanf() 和 scanf() 函数尝试把字符码翻译成转换说明指定的其他类型。例如，输入一个值23，%f 转换说明会把23翻译成一个浮点值，%d 转换说明会把 23 翻译成一个整数值，%s 转换说明则会把 23 存储为字符串。getc() 和 fgetc() 系列函数把输入作为字符码存储，将其作为单独的字符保存在字符变量中或作为字符串储存在字符数组中。类似的，fwrite() 将二进制数据直接放入输出流，而其他输出函数把非字符数据转换成用字符表示后将其放入输出流。

ANSI C 提供两种文件打开模式：二进制和文本。以二进制模式打开文件时，可以逐字节读取文件；以文本模式打开文件时，会把文件内容从文本的系统表示法映射为 C 表示法。对于 UNIX 和 Linux 系统，这两种模式完全相同。

通常，输入函数 getc()、fgetc()、fscanf() 和 fread() 都从文件开始处按顺序读取文件。然而，fseek() 和 ftell() 函数让程序可以随机访问文件中的任意位置。fgetpos() 和 fsetpos() 把类似的功能扩展至更大的文件。与文本模式相比，二进制模式更容易进行随机访问。

### 获取信息的文件类型

如果要想在程序中去获取外部数据，可以从两种文件类型获取信息。

1. 标准输入文件 - stdin（关键字）- 获取源（键盘）
2. 其他已经打开的文件 - 用 fopen() 函数去打开，然后获取其打开后的地址供输入函数去获取信息，输出亦然。

**注意事项**：在使用 open() 函数打开文件获取信息后，等数据处理完之后，一定要使用 fclose() 去把文件关闭，要不然它会一直占用内存空间，并阻碍其他程序去使用哪个文件。