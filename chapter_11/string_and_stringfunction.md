# 字符串和字符串函数

- **字符串**是 C 语言中<u>最有用</u>、<u>最重要的</u>**数据类型**之一。
- **C 库**提供了<u>大量的</u>**函数**用于<u>读写字符串、拷贝字符串、比较字符串、合并字符串、查找字符串</u>等。

### 字符串是什么（字符串的本质）？

- **字符串**是<u>以空字符（\0）结尾的</u> **char 类型数组**。

### 如何声明并初始化字符串？

可以使用多种方式去定义字符串，如，字符串常量、char 类型数组、指向 char 的指针……

#### 1.字符串字面量（字符串常量）

**用双引号括起来的内容**称为**字符串字面量**，也叫作**字符串常量**。<u>双引号中的</u>**字符**和<u>编译器自动加入末尾的</u>**\0字符**（空字符），都作为**字符串**储存在**内存**中，所以 `"I am a symbolic string constant."、"I am a string in an array."、"Someting is pointed at me."、"Here are some strings:"`都是**字符串字面量**。

从 ANSI C 标准起，如果**字符串字面量**之间没有**间隔**，或者用**空白字符**分隔，**C** 会将其视为<u>串联起来的</u>**字符串字面量**。例如：

```c
char greeting[50] = "Hello, and"" how are" " you"
    				" today!";
// 与下面的代码等价：
char greeting[50] = "Hello, and how are you today!";
// 如果要在字符串内部使用双引号，必须在双引号前面加上一个反斜杠（\）：
printf("\"Run, Spot, run!\" exclaimed Dick.\n");
// 输出如下：
"Run, Spot, run!" exclaimed Dick.
```

**字符串常量**属于**静态存储类别**，<u>这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次</u>。

<u>用双引号括起来的</u>**内容**被视为<u>指向该字符串储存位置的</u>**指针**。这类似于把**数组名**作为<u>指向该数组位置的</u>**指针**。

#### 2.字符串数组和初始化

定义字符串数组并初始化时，一个很重要的地方就是要给足够的存储空间。因为，字符串在储存的时候，编译器会自动把双引号包裹的字符和添加在末尾的空字符（\0）一并去存储。所以，字符串存储时实际重要的空间是比字符串的字符数量多一个的。这点要格外注意。可采用两种方式去规避，在初始化字符串数组的时候。

1.  **指定足够大的数组去存储字符串**：

   ```c
   const char ml[40] = "Limit yourself to one line's worth.";
   ```

2.  **让编译器确定字符串数组的大小**：

   ```c
   const char m2[] = "If you can't think of anything, fake it.";
   ```

   **注意事项**：让编译器计算数组的大小只能用在初始化数组时。**如果创建一个稍后再填充的数组，就必须在声明时指定大小**。

- **声明数组时，数组大小必须是可求值的整数**。

- **字符数组名和其他数组名一样，是该数组首元素的地址**。

  ```c
  // 假设有下面的初始化：
  char car[10] = "Tata";
  // 那么，以下表达式都为真：
  car == &car[0];
  *car == 'T';
  *(car+1) == car[1] == 'a';
  ```

- 还可使用**指针表示法创建字符串**。

  ```c
  const char * pt1 = "Something is pointing at me.";
  // 该声明和下面的声明几乎相同：
  const char ar1[] = "Something is pointing at me.";
  // 以上两个声明表明，pt1 和 ar1 都是该字符串的地址。在这两种情况下，带双引号的字符串本身决定了预留给字符串的存储空间。尽管如此，这两种形式并不完全相同。
  ```

#### 3.数组和指针

数组形式和指针形式有何不同？以上面的声明为例，**数组形式（`ar1[]`）在计算机的内存中分配为一个内含29个元素的数组（每个元素对应一个字符，还加上一个末尾的空字符 `\0`），每个元素被初始化为字符串常量对应的字符**。通常，字符串都作为可执行文件的一部分储存在数据段中。**当把程序载入内存时，也载入了程序中的字符串。字符串储存在静态存储区中**。但是，程序在开始运行时才会为该数组分配内存。此时，才将字符串拷贝到数组中。注意，此时字符串有两个副本。一个是在静态内存中的字符字面量，另一个是储存在 ar1 数组中的字符串。

此后，编译器便把数组名 ar1 识别为该数组首元素地址（`&ar1[0]`）的别名。这**里关键要理解，在数组形式中， ar1 是地址常量**。**不能更改 ar1，如果改变了 ar1，则意味着改变了数组的存储位置（即地址）**。可以进行类似 `ar1+1`这样的操作，标识数组的下一个元素。但是不允许进行 `++ar1`这样的操作。递增运算符只能用于变量名前（或概括地说，只能用于可修改的左值），不能用于常量。

指针形式（`*pt1`）也使得编译器为字符串在静态存储区预留29个元素的空间。另外，**一旦开始执行程序，它会为指针变量 pt1 留出一个储存位置，并把字符串的地址储存在指针变量中**。该变量最初指向该字符串的首字符，但是它的值可以改变。因此，可以使用递增运算符。例如， `++pt1`将指向第2个字符（o）。

字符串字面量被视为 const 数据。由于 pt1 指向这个 const 数据，所以应该把 pt1 声明为指向 const 数据的指针。这意味着不能用 pt1 改变它所指向的数据，但是仍然可以改变 pt1 的值（即，pt1 指向的位置）。如果把一个字符串字面量拷贝给一个数组，就可以随意改变数据，除非把数组声明为 const。

总之，**初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针**。

#### 4.数组和指针的区别

```c
// 比较数组和指针的区别
#include <stdio.h>

int main(void)
{
    // 数组的元素是变量（除非数组被声明为 const），但是数组名不是变量。
    char heart[] = "I love Tillie!";
    const char *head = "I love Millie!";
    // 两者主要的区别是：数组名 heart 是常量，而指针名 dead 是变量。
    int i;

    // 首先，两者都可以使用数组表示法：
    for (i = 0; i < 6; i++)
        putchar(heart[i]);
    putchar('\n');
    for (i = 0; i < 6; i++)
        putchar(head[i]);
    putchar('\n');

    // 其次，两者都能进行指针加法操作：
    for (i = 0; i < 6; i++)
        putchar(*(heart + i));
    putchar('\n');
    for (i = 0; i < 6; i++)
        putchar(*(head + i));
    putchar('\n');

    // 但是，只有指针表示法可以进行递增操作：
    // 如果想让数组名也可以使用递增操作，可以用数组名去初始化一个类型相同的指针变量。
    while (*(head) != '\0')
    {
        putchar(*(head++));
    }

    return 0;
}
```

#### 5. 字符串数组

**字符串数组就是“数组元素都为字符串的数组”**。以下演示两种声明方式：**指向字符串的指针数组、char 类型数组的数组**：

```c
// arrchar.c -- 指针数组、字符串数组
#include <stdio.h>
#define SLEN 40
#define LIM 5

int main(void)
{
    // 指向字符串的指针数组（方括号比星号优先级更高，于是初始化时先声明为数组，然后声明元素为指针）
    const char * mytalents[LIM] = {
        "Adding numbers swiftly",
        "Multiplying accurately", "Stashing data",
        "Following instructions to the letter",
        "Understanding the C language"
    };

    // char 类型数组的数组
    char yourtalents[LIM][SLEN] = {
        "Walking in straight line",
        "Sleeping", "Watching television",
        "Mailing letters", "Reading email"
    };
    int i;

    puts("Let's compare talents.");
    printf("%-36s %-25s\n", "My Talents", "Your Talents");
    for (i = 0; i < LIM; i++)
        printf("%-36s %-25s\n", mytalents[i], yourtalents[i]);
    printf("\nsizeof mytalents: %u, sizeof yourtalents: %u\n",
                sizeof(mytalents), sizeof(yourtalents));

    return 0;
}
```

图解**指向字符串的指针数组**（不规则数组）和**char 类型数组的数组**（矩形数组）：

![](C:\Users\Administrator\Desktop\C语言特性\规则数组和不规则数组.jpg)

如果要用数组表示一系列待显示的字符串，请使用指针数组，因为它比二维数组的效率高。但是，指针数组也有自身的缺点。mytalents 中的指针指向的字符串字面量不能更改；而 yourtalentsde 中的内容可以更改。所以，如果要改变字符串或为字符串输入预留空间，不要使用指向字符串字面量的指针。

### 字符串输入函数

**如果想把一个字符串读入程序**，首先**必须预留储存该字符串的空间**，然后**用输入函数获取该字符串**。

#### 分配空间

最简单的方法是，在声明时显式的指明数组的大小（如果未指明 `char * name `其指针地址不可测）：

```c
char name[81]; // 现在 name 是一个已分配块（81字节）的地址
```

#### 读入字符串（输入函数）

- **gets() 函数**——**用于读取整行输入，直至遇到换行符，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符使其成为一个 C 字符串**。它经常与 puts() 函数配对使用，该函数用于显示字符串，并在末尾添加换行符。
  
  - **警告-这是一个废弃的函数**。因为它是不安全的，会导致“缓冲区溢出”。因为它只接受一个参数，导致无法判断输入的字符串是否超过预留空间！！！
  
- **gets()的替代品**

  1. **fgets() 函数（和fputs()）通过第2个参数限制读入的字符数来解决溢出问题**。该函数专门设计用于处理文件输入，所以一般情况下可能不太好用。

     **fget()** 和 **get()**的**区别**如下：

     - **fgets() 函数的第2个参数指明了读入字符的最大数量**。**如果该参数的值是n，那么 fgets()将读入 n-1 个字符，或者读到遇到的第一个换行符为止**，**或者遇到文件结尾也会终止**。

     - **如果 fgets() 读到一个换行符，会把它存储在字符串中**。这点与 gets()不同，gets()会丢弃换行符。

     - **fgets()函数的第3个参数指明要读入的文件**。**如果读入从键盘输入的数据，则以 stdin （标准输入）作为参数，该标识符定义在 stdio.h 中**。

       fgets()函数把换行符放在字符串的末尾（假设输入行不溢出），通常要与 **fputs() 函数**（和puts()类似）配对使用，**该函数不在字符串末尾添加换行符**。**fputs()函数的第2个参数指明它要写入的文件**。**如果要显示在计算机显示器上，应使用 stdout（标准输出）作为该参数**。

       

- **scanf()函数**

  scanf() 和 gets() 或 fgets() 的区别在于他们如何确定字符串的末尾：如果预留的存储区装得下输入行，gets() 和 fgets() 会读取第1个换行符之前的所有字符；**scanf() 更像是“获取单词”的函数，而不是“获取字符串”的函数**。**scanf() 函数有两种方法确定输入结束**。无论哪一种方法，**都从第1个非空白字符作为字符串的开始**。如果使用 %s 转换说明，**以下一个空白字符（空行、空格、制表符或换行符）作为字符串的结束**（字符串不包括空白字符）。如果指定了字段宽度，如 %10s，那么scanf() 将读取 10 个字符或读到第1个空白字符停止（先满足的条件既是结束输入的条件）。

  ![](C:\Users\Administrator\Desktop\C语言特性\字段宽度和scanf函数.jpg)

### 字符串输出函数

C 有 3 个标准库函数用于打印字符串：**puts()**、**fputs()** 和 **printf()**。

- **puts() 函数**接受一个字符串地址作为参数，然后在字符串末尾加上换行符，并输出。
- **fputs() 函数**是 puts() 针对文件定制的版本。它们的区别如下：
  - fputs() 函数的第 2 个函数指明要写入数据的文件。如果要打印在显示器上，可以用定义在 stdio.h 中的 stdout （标准输出）作为参数。
  - 与puts()不同，fputs() 不会再输出的末尾添加换行符。
- **printf()** 函数和 puts() 一样，也把字符串的地址作为参数。printf() 函数可以格式化不同的数据类型，而 puts() 只能输出字符串。

### 为什么要丢弃过长输入行中余下的字符？

因为输入行中多出来的字符会被留在缓冲区中，称为下一次读取语句的输入。例如，如果下一条读取语句要读取的是 double 类型的值，就可能导致程序崩溃。丢弃输入行余下的字符保证了读取语句与键盘输入同步。

### 空字符和空指针

从概念上看，两者完全不同。

空字符（或 '\0'）是用于标记 C 字符串末尾的字符，其对应字符编码是 0。由于其他字符的编码不可能是0，所以不可能是字符串的一部分。

空指针（或NULL)有一个值，该值不会与任何数据的有效地址对应。通常，函数使用它返回一个有效地址表示特殊情况发生，例如遇到文件结尾或未能按预期执行。

**空字符是整型类型，而空指针是指针类型**。两者有时容易混淆的原因是：**它们都可以用数值 0 来表示**。但是，**从概念上看，两者是不同类型的 0**。另外，**空字符是一个字符，占 1 字节**；**而空指针时一个地址，通常占 4 字节**。

**对空字符进行间接运算会得到 0**。这个特性可用于做判断条件，如 `while (*string)` .....

### 缓冲区与输入字符的关系

系统使用缓冲的 I/O。这意味着用户在按下 Return 键之前，输入都被存储在临时存储区（即，缓冲区）中。按下 Return 键就在输入中增加了一个换行符，并把整行输入发送给 fgets()。对于输出，fputs() 把字符发送给另一个缓冲区，当发送换行符，缓冲区中的内容被发送至屏幕上。

### 自定义输入/输出函数

**如果不想使用 C 库中的标准函数，可以在 `getchar()、putchar()`基础上自定义输入、输出函数**。

例如，编写一个类似 `puts()`的函数，但是不会自动添加换行符的函数：

```c
// put1() -- 打印字符串，不添加 \n
#include <stdio.h> // 需要使用 putchar()
void put1(const char * string) // 不会改变字符串，同时形参名也提醒是处理字符串的函数
{
    while (*string) // 当string指向空字符时，*string的值为0，即测试条件为假，while循环结束。
        putchar(*string++);
}
```

例如，设计一个类似 `puts()`的函数，而且该函数还返回待打印字符的个数：

```c
// put2() -- 打印一个字符串，并统计打印的字符数
#include <stdio.h>
int put2(const char * string)
{
    int count = 0;
    while (*string++)
    {
        putchar(*string++);
        count++;
    }
    putchar('\n');  // 不统计换行符
    
    return count;
}
```

### 字符串函数

- 函数原型在“string.h"头文件的：`strlen()、strcan()、strcmp()、strcmp()、strncmp()、strcpy()、strncpy() `
- 函数原型在“stdio.h"头文件中：`sprintf()`
- **`strlen()`函数**用于**统计字符串的长度**。
- **`strcat()`函数**（用于**拼接字符串**）接受龙哥字符串作为参数。该函数把第2个字符串的备份附加在第1个字符串末尾，并把拼接后形成的新字符串作为第1个字符串，第2个字符串不变。`strcat()`函数的类型是 `char *`(即，指向 char 的指针)。`strcat()`函数返回第1个参数，即拼接第2个字符串后的第一个字符串的地址。
- **`strncat()`函数**与是`strcat()`函数的升级版，它有三个参数，第3个参数限定合并给第一个字符串的字符数量，以保证合并的字符没有超出第一个字符串的存储空间，以避免出现“缓冲区泄露的情况”。
- **`strcmp()`函数**用于**比较字符串**。该函数通过比较运算符来比较字符串，就像比较数字一样。**如果两个字符串参数相同，该函数就返回0，否则返回非零值**。
- `strncmp()`函数也用于比较字符串，与 `strcmp()`函数的差异在于前者可以知道比较的长度，而不需要比较完整个字符串。例如 `strncmp(list[i], list[i])` 。
- **`strcpy()`函数**用于**拷贝字符串**，相当于字符串赋值运算符。`strcpy(qwords[i], temp);`（第2个参数）拷贝出来的字符串被称为目标字符串，最初的字符串被称为源字符串。参考赋值表达式语句，很容易记住 `strcpy()`参数的顺序，即第1个是目标字符串，第2个是源字符串。—— `strcpy()`函数接收两个字符串指针作为参数，可以把指向源字符串的第2个指针声明为指针、数组名或字符串常量；而指向源字符串副本的第1个指针应指向一个数据对象（如，数组），且该对象有足够的空间储存源字符串的副本。记住，**声明数组将分配储存数据的空间，而声明指针只分配储存一个地址的空间**。
- **`strncpy()`函数**同样用于拷贝字符串，但它比 `strcpy()`函数更安全，它的第3个参数指明可拷贝的最大字符数，防止目标空间装不下源字符串的副本出现缓冲溢出。
- **`sprintf()`函数**用于**把多个元素合成一个字符串**。`sprintf()`函数声明在 `stdio.h`头文件，它和 `printf()`类似。不同之处是它把数据写入字符串，而不是打印在显示器上。`sprintf()`的第1个参数时目标字符串的地址，其余参数和 `printf()`相同，即格式字符串和待写入项的列表。

### 小结：

**C 字符串是一系列 char 类型的字符，以空字符（'\n'）结尾**。字符串可以储存在**字符数组中**。字符串还可以用**字符串常量**来表示，里面都是字符，括在双引号中（空字符除外）。编辑器提供空字符。因此，“joy”被储存为4个字符j、o、y和\0。**`strlen()`函数可以统计字符串的长度，空字符不计算在内**。

**字符串常量也叫作字符串字面量**，**可用于初始化字符数组**。为了容纳末尾的空字符，数组大小应该至少比容纳的数组长度多1。**也可以用字符串常量初始化指向 char 的指针**。

**函数使用指向字符串首字符的指针来表示待处理的字符串**。通常，对应的**实际参数**时**数组名**、**指针变量**或**用双引号括起来的字符串**。**无论是哪种情况，传递的都是首字符的地址**。一般而言，没必要传递字符串的长度，因为函数可以通过末尾的空字符确定字符串的结束。

`fgets()`函数获取一行输入，`puts()`和 `fputs()`函数显示一行输出。它们都是 `stdio.h`头文件中的函数，用于代替已被弃用的 `gets()`。

C 库中有多个字符串处理函数。在 ANSI C 中，这些函数声明在 `string.h`文件中。C库中还要许多字符处理函数，声明在 `ctype.h`文件中。

给 `main()`函数提供两个合适的形式参数，可以让程序访问命令行参数。第1个参数通常是 int 类型的 argc，其值是命令行的单词数量。第2个参数通常是一个指向数组的指针 argv，数组内含指向 char的指针。每个指向 char 的指针都指向一个命令行参数字符串，argv[0] 指向命令名称，argv[1]指向第1个命令行参数，以此类推。

`atoi()`、`atol()`和 `atof()`函数把字符串形式的数字分别转换成 int、long 和 double 类型的数字。`strtol()`、`strtoul()`和 `strtod()`函数把字符串形式的数字分别转换成 long、unsigned long 和 double 类型的数字。