# 字符串和字符串函数

- **字符串**是 C 语言中<u>最有用</u>、<u>最重要的</u>**数据类型**之一。
- **C 库**提供了<u>大量的</u>**函数**用于<u>读写字符串、拷贝字符串、比较字符串、合并字符串、查找字符串</u>等。

### 字符串是什么（字符串的本质）？

- **字符串**是<u>以空字符（\0）结尾的</u> **char 类型数组**。

### 如何声明并初始化字符串？

可以使用多种方式去定义字符串，如，字符串常量、char 类型数组、指向 char 的指针……

#### 1.字符串字面量（字符串常量）

**用双引号括起来的内容**称为**字符串字面量**，也叫作**字符串常量**。<u>双引号中的</u>**字符**和<u>编译器自动加入末尾的</u>**\0字符**（空字符），都作为**字符串**储存在**内存**中，所以 `"I am a symbolic string constant."、"I am a string in an array."、"Someting is pointed at me."、"Here are some strings:"`都是**字符串字面量**。

从 ANSI C 标准起，如果**字符串字面量**之间没有**间隔**，或者用**空白字符**分隔，**C** 会将其视为<u>串联起来的</u>**字符串字面量**。例如：

```c
char greeting[50] = "Hello, and"" how are" " you"
    				" today!";
// 与下面的代码等价：
char greeting[50] = "Hello, and how are you today!";
// 如果要在字符串内部使用双引号，必须在双引号前面加上一个反斜杠（\）：
printf("\"Run, Spot, run!\" exclaimed Dick.\n");
// 输出如下：
"Run, Spot, run!" exclaimed Dick.
```

**字符串常量**属于**静态存储类别**，<u>这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次</u>。

<u>用双引号括起来的</u>**内容**被视为<u>指向该字符串储存位置的</u>**指针**。这类似于把**数组名**作为<u>指向该数组位置的</u>**指针**。

#### 2.字符串数组和初始化

定义字符串数组并初始化时，一个很重要的地方就是要给足够的存储空间。因为，字符串在储存的时候，编译器会自动把双引号包裹的字符和添加在末尾的空字符（\0）一并去存储。所以，字符串存储时实际重要的空间是比字符串的字符数量多一个的。这点要格外注意。可采用两种方式去规避，在初始化字符串数组的时候。

1.  **指定足够大的数组去存储字符串**：

   ```c
   const char ml[40] = "Limit yourself to one line's worth.";
   ```

2.  **让编译器确定字符串数组的大小**：

   ```c
   const char m2[] = "If you can't think of anything, fake it.";
   ```

   **注意事项**：让编译器计算数组的大小只能用在初始化数组时。**如果创建一个稍后再填充的数组，就必须在声明时指定大小**。

- **声明数组时，数组大小必须是可求值的整数**。

- **字符数组名和其他数组名一样，是该数组首元素的地址**。

  ```c
  // 假设有下面的初始化：
  char car[10] = "Tata";
  // 那么，以下表达式都为真：
  car == &car[0];
  *car == 'T';
  *(car+1) == car[1] == 'a';
  ```

- 还可使用**指针表示法创建字符串**。

  ```c
  const char * pt1 = "Something is pointing at me.";
  // 该声明和下面的声明几乎相同：
  const char ar1[] = "Something is pointing at me.";
  // 以上两个声明表明，pt1 和 ar1 都是该字符串的地址。在这两种情况下，带双引号的字符串本身决定了预留给字符串的存储空间。尽管如此，这两种形式并不完全相同。
  ```

#### 3.数组和指针

数组形式和指针形式有何不同？以上面的声明为例，**数组形式（`ar1[]`）在计算机的内存中分配为一个内含29个元素的数组（每个元素对应一个字符，还加上一个末尾的空字符 `\0`），每个元素被初始化为字符串常量对应的字符**。通常，字符串都作为可执行文件的一部分储存在数据段中。**当把程序载入内存时，也载入了程序中的字符串。字符串储存在静态存储区中**。但是，程序在开始运行时才会为该数组分配内存。此时，才将字符串拷贝到数组中。注意，此时字符串有两个副本。一个是在静态内存中的字符字面量，另一个是储存在 ar1 数组中的字符串。

此后，编译器便把数组名 ar1 识别为该数组首元素地址（`&ar1[0]`）的别名。这**里关键要理解，在数组形式中， ar1 是地址常量**。**不能更改 ar1，如果改变了 ar1，则意味着改变了数组的存储位置（即地址）**。可以进行类似 `ar1+1`这样的操作，标识数组的下一个元素。但是不允许进行 `++ar1`这样的操作。递增运算符只能用于变量名前（或概括地说，只能用于可修改的左值），不能用于常量。

指针形式（`*pt1`）也使得编译器为字符串在静态存储区预留29个元素的空间。另外，**一旦开始执行程序，它会为指针变量 pt1 留出一个储存位置，并把字符串的地址储存在指针变量中**。该变量最初指向该字符串的首字符，但是它的值可以改变。因此，可以使用递增运算符。例如， `++pt1`将指向第2个字符（o）。

字符串字面量被视为 const 数据。由于 pt1 指向这个 const 数据，所以应该把 pt1 声明为指向 const 数据的指针。这意味着不能用 pt1 改变它所指向的数据，但是仍然可以改变 pt1 的值（即，pt1 指向的位置）。如果把一个字符串字面量拷贝给一个数组，就可以随意改变数据，除非把数组声明为 const。

总之，**初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针**。

#### 4.数组和指针的区别

```c
// 比较数组和指针的区别
#include <stdio.h>

int main(void)
{
    // 数组的元素是变量（除非数组被声明为 const），但是数组名不是变量。
    char heart[] = "I love Tillie!";
    const char *head = "I love Millie!";
    // 两者主要的区别是：数组名 heart 是常量，而指针名 dead 是变量。
    int i;

    // 首先，两者都可以使用数组表示法：
    for (i = 0; i < 6; i++)
        putchar(heart[i]);
    putchar('\n');
    for (i = 0; i < 6; i++)
        putchar(head[i]);
    putchar('\n');

    // 其次，两者都能进行指针加法操作：
    for (i = 0; i < 6; i++)
        putchar(*(heart + i));
    putchar('\n');
    for (i = 0; i < 6; i++)
        putchar(*(head + i));
    putchar('\n');

    // 但是，只有指针表示法可以进行递增操作：
    // 如果想让数组名也可以使用递增操作，可以用数组名去初始化一个类型相同的指针变量。
    while (*(head) != '\0')
    {
        putchar(*(head++));
    }

    return 0;
}
```

#### 5. 字符串数组

**字符串数组就是“数组元素都为字符串的数组”**。以下演示两种声明方式：**指向字符串的指针数组、char 类型数组的数组**：

```c
// arrchar.c -- 指针数组、字符串数组
#include <stdio.h>
#define SLEN 40
#define LIM 5

int main(void)
{
    // 指向字符串的指针数组（方括号比星号优先级更高，于是初始化时先声明为数组，然后声明元素为指针）
    const char * mytalents[LIM] = {
        "Adding numbers swiftly",
        "Multiplying accurately", "Stashing data",
        "Following instructions to the letter",
        "Understanding the C language"
    };

    // char 类型数组的数组
    char yourtalents[LIM][SLEN] = {
        "Walking in straight line",
        "Sleeping", "Watching television",
        "Mailing letters", "Reading email"
    };
    int i;

    puts("Let's compare talents.");
    printf("%-36s %-25s\n", "My Talents", "Your Talents");
    for (i = 0; i < LIM; i++)
        printf("%-36s %-25s\n", mytalents[i], yourtalents[i]);
    printf("\nsizeof mytalents: %u, sizeof yourtalents: %u\n",
                sizeof(mytalents), sizeof(yourtalents));

    return 0;
}
```

图解**指向字符串的指针数组**（不规则数组）和**char 类型数组的数组**（矩形数组）：

![](C:\Users\Administrator\Desktop\C语言特性\规则数组和不规则数组.jpg)

如果要用数组表示一系列待显示的字符串，请使用指针数组，因为它比二维数组的效率高。但是，指针数组也有自身的缺点。mytalents 中的指针指向的字符串字面量不能更改；而 yourtalentsde 中的内容可以更改。所以，如果要改变字符串或为字符串输入预留空间，不要使用指向字符串字面量的指针。

### 输入字符串

**如果想把一个字符串读入程序**，首先**必须预留储存该字符串的空间**，然后**用输入函数获取该字符串**。

#### 分配空间

最简单的方法是，在声明时显式的指明数组的大小（如果未指明 `char * name `其指针地址不可测）：

```c
char name[81]; // 现在 name 是一个已分配块（81字节）的地址
```

#### 读入字符串（输入函数）

- **gets() 函数**——**用于读取整行输入，直至遇到换行符，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符使其成为一个 C 字符串**。它经常与 puts() 函数配对使用，该函数用于显示字符串，并在末尾添加换行符。
  - **警告-这是一个废弃的函数**。因为它是不安全的，会导致“缓冲区溢出”。因为它只接受一个参数，导致无法判断输入的字符串是否超过预留空间！！！
- **gets()的替代品**
- **scanf()函数**

### 如何操纵字符串？

### 字符串函数

- **`puts()` 函数**与 `printf()`一样也属于 `stdio.h`系列的输入/输出函数。与 `printf()`不同的是， **`puts()`函数只显示字符串，而且自动在显示的字符串末尾加上换行符**。