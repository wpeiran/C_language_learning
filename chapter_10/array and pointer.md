### 数组

- **数组是由数据类型相同的一系列元素组成**。
- 需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型。编译器根据这些信息正确地创建数组。
- 普通变量可以使用的类型，数组元素都可以用。
- 数组通常被用来存储程序需要的数据。
- 使用**符号常量表示数组大小**，是比较推荐且常用的的做法。

### 使用数组的注意事项

- **使用数组前必须先初始化它**。在使用数组元素之前，必须先给它们赋初始值。否则，编译器将使用的值是内存相应位置上的现有值。 
- **初始化列表中的项数应与数组的大小一致**。当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0。
- 如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值；如果部分初始化数组，剩余的元素会被初始化为 0。
- C 不允许把数组作为一个单元赋给令一个数组，除初始化外，也不允许使用花括号列表的形式赋值。
- 在使用数组时，要防止数组下标超出边界。也就是说，必须确保下标是有效值。**使用越界的数组下标会导致程序改变其他变量的值**。

### 初始化数组

初始化数组的方式：用以逗号分隔的列表（用花括号括起来）来初始化数组，各值之间用逗号分隔。在逗号和值之间可使用空格。

```c
int main(void)
{
 int powers[8] = {1,2,4,6,8,16,32,64}; // 从 ANSI C 开始支持这种初始化方式
 const int powers[8] = {1,2,4,6,8,16,32,64}; // 使用 const 初始化只读数组
}
```

### 指定初始化器

**指定初始化器一种方便的指定数组中某一元素的方法**。而不必像传统的数组初始化一样去指定全部的元素。

示例，初始化数组中的任意元素：

```c
int arr[6] = {[5] = 212};  // 把 arr[5] 初始化为 212
```

#### 指定初始化器的两个重要特性：

- 第一，如果指定初始化器后面有更多的值，那么后面这些值将被用于初始化指定元素后面的元素。
- 第二，如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化值。

### 给数组元素赋值

**声明数组后，可以借助数组下标（或索引）给数组元素赋值**。例如，下面的程序段给数组的所有元素赋值：

```c
// 给数组的元素赋值
#include <stdio.h>
#define SIZE 50
int main(void)
{
    int counter, evens[SIZE];
    
    for (counter = 0; counter < SIZE; counter++)
        evens[counter] = 2 * counter;
    ......
}
```

### 多维数组

多维数组就是**嵌套数组**，即一个数组中的每个元素都是一个数组。声明和调用方式如下：

```c
float rain[5][12]; // 内含5个数组元素的数组，每个数组元素内含12个float类型的元素
rain[0][0]; // 调用第0个数组元素的第0个元素
```

### 指针和数组

#### 为什么使用指针呢？

> 因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。

- 指针提供了一种<u>以符号形式使用地址的</u>方法。

#### C 中指针和数组的关系

- **在 C 中，数组名是该数组首元素的地址**。

  - ```c
    // 如果 flizny 是一个数组，下面的语句成立：
    flizny == &flizny[0] // 数组名是该数组首元素的地址
    ```

- **在 C 中，指针加 1 指的是增加一个存储单元**。**对数组而言，这意味着加 1 后的地址是下一个元素的地址**，而不是下一个字节的地址。这是为什么必须声明所指向对象类型的原因之一。只知道地址不够，因为计算机要知道准出对象需要多少字节（即使指针指向的是标量变量，也要知道变量的类型，否则 *pt 就无法正确的取回地址上的值）。

![](C:\Users\Administrator\Desktop\C语言特性\数组和指针加法_meitu_1.jpg)

- **指针的值是“它所指向对象的地址”**。**地址的表示方式依赖于计算机内部的硬件**。许多计算机（包括PC和Mac）都是**按字节编码**，**意思是内存中的每个字节都按顺序编号**。这里，一个较大对象的地址（如 double 类型的变量）通常是该对象第一个字节的地址。
- 在指针前面使用 `*` 运算符可以得到<u>该指针所指对象的</u>值。

#### C 语言的灵活性

```c
dates + 2 == &date[2] 		// 相同的地址
*(dates + 2) == dates[2]	// 相同的值
```

以上的关系等式体现了 C 语言的灵活性；同时也表明了数组和指针的关系十分密切，可以使用指针标识数组的元素和获得元素的值。

**从本质上看，就是“同一个对象有两种表示法”**。数组的元素可以用**索引（数组表示法）**或**指针（指针表示法）**的方式去表示数组中的同一个元素。

- **数组表示法和指针表示法**，在编译器编译这两种写法时生成的代码相同。也就是说，**它们是两种等效的方法**。—— 它们**彼此之间可以互换表示**（如上的代码示例）。**结合实际情况去选择表达方式**。

### 函数、数组和指针

**函数要处理数组必须知道何时开始、何时结束**。可实现的两种方式方式：

- **数组表示法**：函数使用一个指针形参数组的开始，用一个整数形参表明待处理数组的元素的个数（指针形参也表明了数组中的数据类型）。
- **指针表示法**：函数使用两个指针参数，第1个指针指明数组的开始出（与前面用法相同），第2个指针指明数组的结束处。

### 指针操作

可对指针变量进行的基本操作：

- **赋值**：可以把地址赋给指针。例如，用数组名、带地址运算符（&）的变量名、另一个指针进行赋值。
- **解引用**：`*`运算符给出指针指向地址上存储的值。
- **取值**：和所有变量一样，指针变量也有自己的地址和值。对指针而言，`&`运算符给出指针本身的地址。
- **指针与整数相加**：可以使用 `+` 运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。
- **递增指针**：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。
- **指针与整数相减**：可以使用 `-`运算符从一个指针中减去一个整数。**指针必须是第1个运算对象，整数是第2个运算对象**。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。
- **递减指针**：除了递增指针还可以递减指针。前缀或后缀的递增和递减运算符都可以使用。
- **指针求差**：可以计算两个指针的差值。通常，**求差的两个指针分别指向同一个数组的不同元素，通过计算求出两个元素之间的距离**。差值的单位与数组类型的单位相同。如果指向两个不同数组的指针进行求差运算可能会得出一个值，或者导致运行时错误。
- **比较**：使用关系运算符可以比较两个指针的值，**前提是两个指针都指向相同类型的对象**。

#### 注意事项：

- 在递增或递减指针时还要注意一些问题。编译器不会检查指针是否仍指向数组元素。C 只能保证指向数组任意元素的指针和指向数组后面第1个位置的指针有效。但是，如果递增或递减一个指针后超出了这个范围，则是为定义的。另外，可以解引用指向数组任意元素的指针。但是，即使指针指向数组后面一个位置是有效的，也能解引用这样的越界指针。
- 一定要牢记一点：**千万不要解引用为初始化的指针**。切记：**创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存**。因此，**在使用指针之前，必须先用已经分配的地址初始化它**。例如，可以用一个现有变量的地址初始化该指针（使用带指针形参的函数时，就属于这种情况）。无论如何，使用指针时一定要注意，不要解引用未初始化的指针！！

#### 指针的基本用法：

- **指针的第1个基本用法是在函数间传递信息**。如果希望在被调函数中改变主调函数的变量，必须使用指针。
- **指针的第2个基本用法是用在处理数组的函数中**。

### 保护数组中的数据

在C中调用数组中的数据是通过指针去实现的，这样效率最高；当然也可以通过传递值的方式，但那样在函数中使用数组就非常耗费空间。使用数组在函数中可以方便的调用元素的同时，也有它的弊端就是可能因为程序错误而把数组中的数据错误处理。

我们在函数中调用数组数据的时候会设计两种使用方式：修改数值中的数据、不修改数组中的数据。那么，在不不修改数组中的数据的时候如何保护数组中的数据呢？可以使用声明常量的方式去保护数组中的数据。

#### const（constant - 不变的、恒定的） 的声明方式：

- **const 数组**：**声明为 const 类型的数组，其元素是不能被改变的**。

  - ```c
    #define MONTHS 12
    ......
    const int days[MONTHS] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    days[9] = 44; // 编译错误
    ```

    

- **指向 const 的指针**：**指向 const 的指针不能用于改变值，但可以改变指向地址**。

  - ```c
    double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
    const double * pd = rates;	// pd 指向数组的首元素
    // 第2行代码把 pd 指向的 double 类型的值声明为 const，这表示不能使用 pd 来更改它所指向的值：
    *pd = 29.89;	// 不允许
    pd[2] = 222.22; // 不允许
    rates[0] = 99.99; // 允许，因为 rates 未被 const 限定
    /*无论是使用指针表示法还是数组表示法，都不允许使用pd修改它所指向数据的值。但是要注意，因为retes并未被声明为const，所以仍然可以通过rates修改元素的值。另外，可以让pd指向别处：*/
    pd++;  // 让pd指向rates[1] -- 没问题
    // 指向const的指针通常用于函数形参中，表明该函数不会使用指针改变数据。例如如下的函数声明：
    void show_array(const double *ar, int n);
    ```

  - **关于指针赋值和const需要注意一些规则**：

    - 首先，**把 const 数据或非 const 数据的地址初始化为指向const的指针或为其赋值是合法的**：

      - ```c
        double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
        const double locked[4] = {0.08, 0.075, 0.0725, 0.07};
        const double * pc = retes;  // 有效
        pc = locked;				// 有效
        pc = &rates[3];				// 有效
        ```

    - 然而，**只能把非 const 数据的地址赋给普通指针**：

      - ```c
        double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
        const double locked[4] = {0.08, 0.075, 0.0725, 0.07};
        const double * pc = retes;  // 有效
        pc = locked;				// 无效
        pc = &rates[3];				// 有效
        ```

    - **这个规则非常合理。否则，通过指针就能改变 const 数组中的数据**。

- **const 指针**：用于**声明并初始化一个不能指向别处的指针**。**关键是 const 的位置**：

  - ```c
    double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
    double * const pc = rates;  // pc 指向数组的开始
    pc = &rates[2];             // 不允许，因为该指针不能指向别处
    *pc = 92.99;				// 没问题--更改 rates[0] 的值
    // 可以用这种指针修改它所指向的值，但是它只能指向初始化时设置的地址。
    ```

- **const 的 const 指针**：**该指针即不能更改它所指向的地址，也不能修改指向地址上的值**：

  - ```c
    double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
    const double * const pc = rates;
    pc = &rates[2];		// 不允许
    *pc = 92.99;		// 不允许
    ```

    



