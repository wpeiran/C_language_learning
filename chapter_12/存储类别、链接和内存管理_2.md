# 存储类别、链接和内存管理

- **合理使用内存储存数据是设计程序的一个要点**。—— 程序员通过 C 的内存管理系统指定变量的作用域和生命期，实现对程序的控制。
- **标识符**用于访问对象，可以用**作用域**和**链接**描述标识符，**标识符的作用和链接表明了程序的那些部分可以使用它**。
- **对象**（object）在C语言中，**是指物理内存中的一块内存空间**。
  - 在软件方面看，可以通过声明标识符（变量、指针、数组）去指定一个特定的对象用于储存数据。
- **存储期**（storage duration）所谓存储期**是指对象在内存中保留多长时间**。
  - 可以用**存储期**描述**对象**

不同的存储类别具有不同的存储期、作用域和链接。标识符可以在源代码的多文件中共享、可用于特定文件的任意函数中、可仅限于特定函数中使用，甚至只在函数中的某部分使用。对象可存在于程序的执行期，也可以仅存在于它所在的函数的执行期。对于并发编程，对象可以在特定线程的执行期存在。可以通过函数调用的方式显式分配和释放内存。

### 作用域

**作用域**描述**程序中可访问标识符的区域**。**一个 C 变量的作用域**可以是**块作用域**、**函数作用域**、**函数原型作用域**或**文件作用域**。

- **块**是**用一对花括号括起来的代码区域**。例如，整个函数体是一个块，**函数中的任意复合语句也是一个块**。

- **定义在块中的变量**具有**块作用域**，**块作用域变量的可见范围是从定义处到包含该定义的块的末尾**。另外，虽然函数的形式参数声明在左括号之前，但是它们具有块作用域，属于函数体这个块。块作用域适用的块：

  1. 函数
  2. for循环
  3. while循环
  4. do while 循环
  5. if 语句

- 函数作用域仅用于 goto 语句的标签。（goto语句是弃用的语句，因此函数作用域不用关注）。

- **函数原型作用域**用于函数原型中的形参名（变量名），**函数原型作用域的范围是从形参定义处到原型声明结束**。这意味着，编译器在处理函数原型中的形参时只关注它的类型，而形参名（如果有的话）通常无关紧要。而且，即使有形参名，也不必与函数定义中的形参名相匹配。只有在变长数组中，形参名才有用：

  ```c
  int mighty(int mouse, double large); // 形参名可忽略
  void use_a(int n, int m, ar[n][m]); // （变长数组）方括号中必须使用在函数原型中已声明的名称
  ```

- **定义在函数外面的变量**具有**文件作用域**。**具有文件作用域的变量，从它的定义处到该定义所在文件的末尾均可见**。由于这样的变量可用于多个函数，所以文件作用域变量可称为**全局变量**。

### 翻译单元

**翻译单元，是指一个源文件和它所包含的头文件在编译之后的称呼。因为，C 预处理实际上是用头文件包含的内容替换#include指令**。也就是说，头文件中的内容和源代码会拼接到一块，形成一个新的文件，而它被称为“翻译单元”。如果一个程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。—— **一个具有文件作用域的变量，它的实际可见范围是整个翻译单元**。

### 链接

C 变量有3中链接属性：**外部链接**、**内部链接**或**无链接**。

- **具有块作用域、函数作用域或函数原型作用域的变量**都是**无链接变量**。这意味着这些变量属于定义它们的块、函数或原型私有。

- **具有文件作用域的变量**可以是**外部链接**或**内部链接**。

  - **外部链接变量**可以**在多个文件程序中使用**；
  - **内部链接变量**只能**在一个翻译单元中使用**。

  C 标准用“内部链接的文件作用域”描述仅限于一个翻译单元（即一个源代码文件和它所包含的头文件）的作用域，用“外部链接的文件作用域”描述可延伸至其他翻译单元的作用域。但是，对程序员而言这些术语太长了。一些程序员把“内部链接的文件作用域”简称为“文件作用域”，把“外部链接的文件作用域”简称为“全局作用域”或“程序作用域”。

- **如何知道文件作用域变量是内部链接还是外部链接**？——可以查看外部定义中是否使用了存储类别说明符 `static`：

  ```c
  int giants = 5; 			// 文件作用域，外部链接
  static int dodgers = 3; 	// 文件作用域，内部链接
  int main(void)
  ......
  // 该文件和同一程序的其他文件都可以使用变量 giants。而变量 dodgers 属于文件私有，该文件中的任意函数都可以使用它。
  ```

### 存储期

作用域和链接描述了标识符的可见性。**存储期**描述了<u>通过这些标识符访问的对象的</u>**生存期**。**C 对象有4种存储期**：**静态存储期**、**线程存储期**、**自动存储期**、**动态分配存储期**。

- **静态存储期**：**如果对象具有静态存储期，那么它在程序的执行期间一直存在**。
  - **文件作用域变量具有静态存储期**。
  - **注意**：对于文件作用域变量，**关键字static表明了其链接属性，而非存储期**。以static声明的文件作用域具有内部链接。但是无论是内部链接还是外部链接，所有的文件作用域变量都具有静态存储期。
- **线程存储期**：用于并发程序设计，程序执行可被分为多个线程。**具有线程存储期的对象，从被声明时到线程结束一直存在**。**以关键字 `_Thread_local`声明一个对象时，每个线程都获得该变量的私有备份**。
- **自动存储期**：**块作用域的变量**通常**都具有自动存储期**。**当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存**。这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存区。例如，一个函数调用结束后，其变量占用的内存可用于存储下一个被调用函数的变量。
  - 变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的开始处到块的末尾。

### 存储类别

存储类别有**5种**：**自动、寄存器、静态块作用域（静态无链接）、静态外部链接、静态内部链接**：

| 存储类别     | 存储期 | 作用域 | 链接 | 声明方式                      |
| ------------ | ------ | ------ | ---- | ----------------------------- |
| 自动         | 自动   | 块     | 无   | 块内                          |
| 寄存器       | 自动   | 块     | 无   | 块内，使用关键字 register     |
| 静态外部链接 | 静态   | 文件   | 外部 | 所以函数外                    |
| 静态内部链接 | 静态   | 文件   | 内部 | 所以函数外，使用关键字 static |
| 静态无链接   | 静态   | 块     | 无   | 块内，使用关键字 static       |

#### 自动变量

属于自动存储类别的变量具有自动存储期、块作用域且无链接。默认情况下，声明在块或函数头中的任何变量都属于自动存储类别。

- **块作用域和无链接意味着只有在变量定义所在的块中才能通过变量名访问该变量**（当然，参数用于传递变量的值和地址给另一个函数，但是这是间接的方法）。另一个函数可以使用同名变量，但是该变量是储存在不同内存位置上的另一个变量。
- **变量具有自动存储期意味着，程序在进入该变量声明所在的块时变量存在，程序在退出该块时变量消失**。原来该变量占用的内存位置现在可做他用。
- 【明确新特性，不建议使用】**如果在内层块中声明的变量与外层块中的变量同名会怎样**？内层块会隐藏外层块的定义。但是离开内层块后，外层块变量的作用域又回到了原来的作用域。
- 【C99特性】作为循环或if语句的一部分，即使不使用花括号（{}），也是一个块。
- 自动变量不会自动初始化，除非显式初始化它。

```c
int main(void)
{
    int repid; // repid 变量的值是之前占用分配给repid的空间的任意值（如果有的话），别指望这个值是0
    int tents = 5; // tents 变量被初始化为5
    int ruth = 1;
    int rance = 5 * ruth; // 可以用非常量表达式初始化自动变量，前提是所用的变量已在前面定义过
}
```

#### 寄存器变量

绝大多数方面，它与自动变量一样。它们都是块作用域、无链接和自动存储期。与普通变量不同的是，访问和处理它的速度更快。但是，由于寄存器变量储存在寄存器而非内存中，所以**无法获得寄存器变量的地址**。

- **注意事项**：声明变量为 register 类别与直接命令相比更像是一种请求。也就是说，声明成功与否取决于是否有足够的寄存器来满足请求。请求失败的情况下，寄存器变量就变成普通的自动变量。即使是这样，仍然不能对该变量使用地址运算符。
- **注意事项**：可声明为 register 的数据类型有限。例如，处理器中的寄存器可能没有足够大的空间来储存 double 类型的值。
- 使用存储类别说明符 register 便可声明寄存器变量：

```c
int main(void)
{
    register int quick;
}
void macho(register int n) // 在函数头中使用关键字register，便可请求形参是寄存器变量
```

#### 块作用域的静态变量

<u>静态变量的</u>**静态**是指“**该变量在内存中原地不动，并不是说它的值不变**”。它和自动变量一样，具有相同的作用域，但是程序离开它们所在的函数后，这些变量不会消失。也就是说，**这种变量具有块作用域、无链接，但是具有静态存储期**。计算机在多次函数调用之间会记录它们的值。

- 声明方式：在块中（提供块作用域和无链接）以存储类别说明符 static （提供静态存储期）声明这种变量。

```c
void trystat(void)
{
    // 第1条声明确实是trystat()函数的一部分，每次调用该函数时都会执行这条声明；这是运行时行为。
    int fade = 1;		
    // 第2条声明实际上并不是trystat()函数的一部分。如果逐步调用该程序会发现，程序似乎跳过了这条声明。
    // 这是因为静态变量和外部变量在程序被载入内存时已执行完毕。这条声明放在trystat()函数中是为了告诉
    // 编译器只有trystat()函数才能看到该变量。这条声明并未在运行时执行。
    static int stay = 1;
    .....
}
int work(static int flu); // 不允许，不能在函数的形参中使用 static
```

#### 外部链接的静态变量

外部链接的静态变量**具有文件作用域、外部链接和静态存储期**。该类别有时称为外部存储类别，属于该类别的变量称为外部变量。**把变量的定义性声明放在所以函数之外便创建了外部变量**。当然，为了指出该函数使用了外部变量，可以在函数中用关键字 extern 再次声明。**如果一个源代码文件使用的外部变量定义在另一个源代码文件中，则必须用 extern 在该文件中声明该变量**。如下所以：

```c
int Errupt;			// 外部定义的变量
double Up[100];		// 外部定义的数组
extern char Coal;	// 如果 Coal 被定义在另一个文件中，则必须这样声明

int main(void)
{
    extern int Errupt;	// 可选的声明
    extern double Up[]; // 可选的声明
    ......
}
```

**注意事项**：如果函数中有与外部变量同名的局部变量，在执行块中的语句时，块作用域中的变量将“隐藏”文件作用域的同名变量。如果不得已要使用与外部变量同名的局部变量，可以在局部变量的声明中使用 auto 存储类别说明符明确表达这种意图。

### 头文件

#### 头文件声明的区别

- 用 **`<xxx.h>`**包裹的头文件**告知编译器去存放标准头文件的位置去查找文件**。
- 用 **`"xxx.h"`**包裹的头文件**告知编译器在本地查找文件**。
  - “**本地查找**”的含义取决于具体的实现。一些**常见的实现把头文件与源代码文件或工程文件（如果编译器使用它们的话）放在相同的目录或文件夹中**。


### 本章小结

**内存**用于**存储程序中的数据**，由**存储期**、**作用域**和**链接**表征。

**存储期**可以是**静态的**、**自动的**或**动态分配的**。

- 如果是**静态存储期**，**在程序开始执行时分配内存，并在程序运行时都存在**。
- 如果是**自动存储期**，**在程序进入变量定义所在块时分配变量的内存，在程序离开块时释放内存**。
- 如果是**动态分配存储期**，**在调用 malloc() （或相关函数）时分配内存，在调用 free() 函数时释放内存**。

**作用域**决定**程序的那些部分可以访问某数据**。

- **定义在所以函数之外的变量**具有**文件作用域**，**对位于该变量声明之后的所有函数都可见**。
- **定义在块或作为函数形参内的变量**具有**块作用域**，**只对该块以及它包含的嵌套块可见**。

**链接**描述定义**在程序某翻译单元中的变量可被链接的程度**。

- **具有块作用域的变量**是**局部变量**，**无链接**。
- **具有文件作用域的变量**可以是**内部链接**或**外部链接**。
  - **内部链接**意味着**只有其定义所在的文件才能使用该变量**。
  - **外部链接**意味着**其他文件也可以使用该变量**。

下面是 **C （不同变量）的 5 种存储类别**（不包括线程的概念）：

- **自动** —— <u>在块中不带存储类别说明符或带 auto 存储类别说明符声明的</u>**变量**（或作为函数头中的形参）属于**自动存储类别**，具有**自动存储期、块作用域、无链接**。**如果未初始化自动变量，它的值是未定义的**。
- **寄存器** —— <u>在块中带 register 存储类别说明符声明的</u>**变量**（或作为函数头中的形参）属于**寄存器存储类别**，具有**自动存储期、块作用域、无链接，且无法获取其地址**。把一个变量声明为寄存器变量**即请求编译器将其存储到访问速度最快的区域**。**如果为初始化寄存器变量，它的值是未定义的**。
- **静态、无链接** —— <u>在块中带 static 存储类别说明符声明的</u>**变量**属于**“静态、无链接”存储类别**，具有**静态存储期、块作用域、无链接**。**只在编译时被初始化一次**。**如果未显式初始化，它的字节都被设置为 0**。
- **静态、外部链接** —— <u>在所有函数外部且没有使用 static 存储类别说明符声明的</u>**变量**属于**“静态、外部链接”存储类别**，具有**静态存储期、文件作用域、外部链接**。**只在编译时被初始化一次**。**如果未显式初始化，它的字节被设置为0**。
- **静态、内部链接** —— **在所有函数外部且使用了 static 存储类别说明符声明的****变量**属于**“静态、内部链接”存储类别**，具有**静态存储期、文件作用域、内部链接**。**只在编译时被初始化一次**。**如果未显式初始化，它的字节都被设置为0**。

动态分配的内存由 malloc()（或相关）函数分配，该函数返回一个指向指定字节数内存块的指针。这块内存被 free() 函数释放便可重复使用，free() 函数以该内存块的地址作为参数。

**类型限定符** const、volatile、restrict 和 _Atomic：

- **const 限定符**限定**数据在程序运行时不能改变**。对指针使用 const 时，可限定指针本身不能改变或指针指向的数据不能改变，这取决于 const 在指针声明中的位置。
- **volatile 限定符**表明**限定的数据除了被当前程序修改外还可以被其他进程修改**。**该限定符的目的是警告编译器不要进行假定的优化**。
- **restrict 限定符**也是**为了方便编译器刷知优化方案**。**restrict 限定的指针是访问所指向数据的唯一途径**。

