# 存储类别、链接和内存管理

- **合理使用内存储存数据是设计程序的一个要点**。—— 程序员通过 C 的内存管理系统指定变量的作用域和生命期，实现对程序的控制。
- **标识符**用于访问对象，可以用**作用域**和**链接**描述标识符，**标识符的作用和链接表明了程序的那些部分可以使用它**。
- **对象**（object）在C语言中，**是指物理内存中的一块内存空间**。
  - 在软件方面看，可以通过声明标识符（变量、指针、数组）去指定一个特定的对象用于储存数据。
- **存储期**（storage duration）所谓存储期**是指对象在内存中保留多长时间**。
  - 可以用**存储期**描述**对象**

不同的存储类别具有不同的存储期、作用域和链接。标识符可以在源代码的多文件中共享、可用于特定文件的任意函数中、可仅限于特定函数中使用，甚至只在函数中的某部分使用。对象可存在于程序的执行期，也可以仅存在于它所在的函数的执行期。对于并发编程，对象可以在特定线程的执行期存在。可以通过函数调用的方式显式分配和释放内存。

### 作用域

**作用域**描述**程序中可访问标识符的区域**。**一个 C 变量的作用域**可以是**块作用域**、**函数作用域**、**函数原型作用域**或**文件作用域**。

- **块**是**用一对花括号括起来的代码区域**。例如，整个函数体是一个块，**函数中的任意复合语句也是一个块**。

- **定义在块中的变量**具有**块作用域**，**块作用域变量的可见范围是从定义处到包含该定义的块的末尾**。另外，虽然函数的形式参数声明在左括号之前，但是它们具有块作用域，属于函数体这个块。块作用域适用的块：

  1. 函数
  2. for循环
  3. while循环
  4. do while 循环
  5. if 语句

- 函数作用域仅用于 goto 语句的标签。（goto语句是弃用的语句，因此函数作用域不用关注）。

- **函数原型作用域**用于函数原型中的形参名（变量名），**函数原型作用域的范围是从形参定义处到原型声明结束**。这意味着，编译器在处理函数原型中的形参时只关注它的类型，而形参名（如果有的话）通常无关紧要。而且，即使有形参名，也不必与函数定义中的形参名相匹配。只有在变长数组中，形参名才有用：

  ```c
  int mighty(int mouse, double large); // 形参名可忽略
  void use_a(int n, int m, ar[n][m]); // （变长数组）方括号中必须使用在函数原型中已声明的名称
  ```

- **定义在函数外面的变量**具有**文件作用域**。**具有文件作用域的变量，从它的定义处到该定义所在文件的末尾均可见**。由于这样的变量可用于多个函数，所以文件作用域变量可称为**全局变量**。

### 翻译单元

**翻译单元，是指一个源文件和它所包含的头文件在编译之后的称呼。因为，C 预处理实际上是用头文件包含的内容替换#include指令**。也就是说，头文件中的内容和源代码会拼接到一块，形成一个新的文件，而它被称为“翻译单元”。如果一个程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。—— **一个具有文件作用域的变量，它的实际可见范围是整个翻译单元**。

### 链接

C 变量有3中链接属性：**外部链接**、**内部链接**或**无链接**。

- **具有块作用域、函数作用域或函数原型作用域的变量**都是**无链接变量**。这意味着这些变量属于定义它们的块、函数或原型私有。

- **具有文件作用域的变量**可以是**外部链接**或**内部链接**。

  - **外部链接变量**可以**在多个文件程序中使用**；
  - **内部链接变量**只能**在一个翻译单元中使用**。

  C 标准用“内部链接的文件作用域”描述仅限于一个翻译单元（即一个源代码文件和它所包含的头文件）的作用域，用“外部链接的文件作用域”描述可延伸至其他翻译单元的作用域。但是，对程序员而言这些术语太长了。一些程序员把“内部链接的文件作用域”简称为“文件作用域”，把“外部链接的文件作用域”简称为“全局作用域”或“程序作用域”。

- **如何知道文件作用域变量是内部链接还是外部链接**？——可以查看外部定义中是否使用了存储类别说明符 `static`：

  ```c
  int giants = 5; 			// 文件作用域，外部链接
  static int dodgers = 3; 	// 文件作用域，内部链接
  int main(void)
  ......
  // 该文件和同一程序的其他文件都可以使用变量 giants。而变量 dodgers 属于文件私有，该文件中的任意函数都可以使用它。
  ```

### 存储期

作用域和链接描述了标识符的可见性。**存储期**描述了<u>通过这些标识符访问的对象的</u>**生存期**。**C 对象有4种存储期**：**静态存储期**、**线程存储期**、**自动存储期**、**动态分配存储期**。

- **静态存储期**：**如果对象具有静态存储期，那么它在程序的执行期间一直存在**。
  - **文件作用域变量具有静态存储期**。
  - **注意**：对于文件作用域变量，**关键字static表明了其链接属性，而非存储期**。以static声明的文件作用域具有内部链接。但是无论是内部链接还是外部链接，所有的文件作用域变量都具有静态存储期。
- **线程存储期**：用于并发程序设计，程序执行可被分为多个线程。**具有线程存储期的对象，从被声明时到线程结束一直存在**。**以关键字 `_Thread_local`声明一个对象时，每个线程都获得该变量的私有备份**。
- **自动存储期**：**块作用域的变量**通常**都具有自动存储期**。**当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存**。这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存区。例如，一个函数调用结束后，其变量占用的内存可用于存储下一个被调用函数的变量。
  - 变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的开始处到块的末尾。

### 存储类别

存储类别有**5种**：**自动、寄存器、静态块作用域（静态无链接）、静态外部链接、静态内部链接**：

| 存储类别     | 存储期 | 作用域 | 链接 | 声明方式                      |
| ------------ | ------ | ------ | ---- | ----------------------------- |
| 自动         | 自动   | 块     | 无   | 块内                          |
| 寄存器       | 自动   | 块     | 无   | 块内，使用关键字 register     |
| 静态外部链接 | 静态   | 文件   | 外部 | 所以函数外                    |
| 静态内部链接 | 静态   | 文件   | 内部 | 所以函数外，使用关键字 static |
| 静态无链接   | 静态   | 块     | 无   | 块内，使用关键字 static       |

#### 自动变量

属于自动存储类别的变量具有自动存储期、块作用域且无链接。默认情况下，声明在块或函数头中的任何变量都属于自动存储类别。

- **块作用域和无链接意味着只有在变量定义所在的块中才能通过变量名访问该变量**（当然，参数用于传递变量的值和地址给另一个函数，但是这是间接的方法）。另一个函数可以使用同名变量，但是该变量是储存在不同内存位置上的另一个变量。
- **变量具有自动存储期意味着，程序在进入该变量声明所在的块时变量存在，程序在退出该块时变量消失**。原来该变量占用的内存位置现在可做他用。
- 【明确新特性，不建议使用】**如果在内层块中声明的变量与外层块中的变量同名会怎样**？内层块会隐藏外层块的定义。但是离开内层块后，外层块变量的作用域又回到了原来的作用域。
- 【C99特性】作为循环或if语句的一部分，即使不使用花括号（{}），也是一个块。
- 自动变量不会自动初始化，除非显式初始化它。

```c
int main(void)
{
    int repid; // repid 变量的值是之前占用分配给repid的空间的任意值（如果有的话），别指望这个值是0
    int tents = 5; // tents 变量被初始化为5
    int ruth = 1;
    int rance = 5 * ruth; // 可以用非常量表达式初始化自动变量，前提是所用的变量已在前面定义过
}
```

#### 寄存器变量

绝大多数方面，它与自动变量一样。它们都是块作用域、无链接和自动存储期。与普通变量不同的是，访问和处理它的速度更快。但是，由于寄存器变量储存在寄存器而非内存中，所以**无法获得寄存器变量的地址**。

- **注意事项**：声明变量为 register 类别与直接命令相比更像是一种请求。也就是说，声明成功与否取决于是否有足够的寄存器来满足请求。请求失败的情况下，寄存器变量就变成普通的自动变量。即使是这样，仍然不能对该变量使用地址运算符。
- **注意事项**：可声明为 register 的数据类型有限。例如，处理器中的寄存器可能没有足够大的空间来储存 double 类型的值。
- 使用存储类别说明符 register 便可声明寄存器变量：

```c
int main(void)
{
    register int quick;
}
void macho(register int n) // 在函数头中使用关键字register，便可请求形参是寄存器变量
```

#### 块作用域的静态变量

<u>静态变量的</u>**静态**是指“**该变量在内存中原地不动，并不是说它的值不变**”。它和自动变量一样，具有相同的作用域，但是程序离开它们所在的函数后，这些变量不会消失。也就是说，**这种变量具有块作用域、无链接，但是具有静态存储期**。计算机在多次函数调用之间会记录它们的值。

- 声明方式：在块中（提供块作用域和无链接）以存储类别说明符 static （提供静态存储期）声明这种变量。

```c
void trystat(void)
{
    // 第1条声明确实是trystat()函数的一部分，每次调用该函数时都会执行这条声明；这是运行时行为。
    int fade = 1;		
    // 第2条声明实际上并不是trystat()函数的一部分。如果逐步调用该程序会发现，程序似乎跳过了这条声明。
    // 这是因为静态变量和外部变量在程序被载入内存时已执行完毕。这条声明放在trystat()函数中是为了告诉
    // 编译器只有trystat()函数才能看到该变量。这条声明并未在运行时执行。
    static int stay = 1;
    .....
}
int work(static int flu); // 不允许，不能在函数的形参中使用 static
```

#### 外部链接的静态变量

外部链接的静态变量**具有文件作用域、外部链接和静态存储期**。该类别有时称为外部存储类别，属于该类别的变量称为外部变量。**把变量的定义性声明放在所以函数之外便创建了外部变量**。当然，为了指出该函数使用了外部变量，可以在函数中用关键字 extern 再次声明。**如果一个源代码文件使用的外部变量定义在另一个源代码文件中，则必须用 extern 在该文件中声明该变量**。如下所以：

```c
int Errupt;			// 外部定义的变量
double Up[100];		// 外部定义的数组
extern char Coal;	// 如果 Coal 被定义在另一个文件中，则必须这样声明

int main(void)
{
    extern int Errupt;	// 可选的声明
    extern double Up[]; // 可选的声明
    ......
}
```

**注意事项**：如果函数中有与外部变量同名的局部变量，在执行块中的语句时，块作用域中的变量将“隐藏”文件作用域的同名变量。如果不得已要使用与外部变量同名的局部变量，可以在局部变量的声明中使用 auto 存储类别说明符明确表达这种意图。